from func import compose, partial2
import numpy as np
from functools import partial
import operator as op
from itertools import islice, ifilter
from fn.iters import splitby
from operator import methodcaller
from func import compose_all, pmap, psplit, _not


_in = partial(methodcaller, '__contains__')

norm_matrix = partial(np.linalg.norm, axis=1)
dist_matrix = compose(norm_matrix, op.sub)
min_dist_position = compose(np.argmin, dist_matrix)

def gravity(M):
    return M.sum(axis=0)/float(len(M))

def k_means_cluster(data, centers=None, k=None):
    assert (centers is not None or k is not None)
    if centers is None:
        centers = np.empty((k, data.shape[1]))
        centers[:] = data[:k]
    old_centers = centers.copy()
    mincenters = partial(min_dist_position, centers)
    data_by_cluster = np.apply_along_axis(mincenters, 1, data)
    for i, _ in enumerate(centers):
        cluster = data[data_by_cluster == i]
        centers[i] = gravity(cluster)
    if np.array_equal(old_centers, centers):
        return centers
    else:
        return k_means_cluster(data, centers)


#def distortion(data, centers):
#    mindests = np.array(map(partial(mindist, centers=centers), data))
#    return (mindests**2).mean()
#
print k_means_cluster(data, k=2)



makenp = compose_all(np.array, pmap(np.array), pmap(float), psplit(' '))
def makematrices(s):
    _centers, _data = splitby(_not(_in('------')), ifilter(bool, s))
    centers = map(makenp, islice(_centers, 1, None))
    data = map(makenp, islice(_data, 1, None))
    return centers, data
#centers, data = makematrices(lines.split('\n'))
lines = open('SquaredErrorDistortion.txt').readlines()
centers, data = makematrices(lines)
#print centers, data
actual= distortion(data, centers)
print actual
#expected = 36.763

#np.testing.assert_almost_equal(expected, actual)
'''
