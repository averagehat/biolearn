import numpy as np
from functools import partial
from operator import itemgetter
from func import compose, compose_all, partial2, ilen

    F = partial
    NE = np.nan

def npGraph(matrix):
    M=matrix
    get = M.__getitem__
    _set = M.__setitem__
    rowndiag = range(0, start) + range(start+1, M.shape[0])
    colndiag = range(0, end) + range(end+1, M.shape[1])
    is_neighbor = compose(has_edge, row_non_diag)
    neighbor_weights = compose_all(get, is_neighbor)
    neighbors = compose(np.nonzero, is_neighbor)
    degree = compose(ilen, neighbor_weights)
    row_non_diag = partial(get, range(0, start) + range(start+1, M.shape[0]))
    update_row = partial(update, j=slice(None))
    update_col = partial(update, i=slice(None))
    update_node = both(update_row, update_col)
    update_row_n = partial(update, j=rowndiag)
    update_col_n = partial(update, i=colndiag)
    update_neighbors = both(update_row_n, update_col_n)
    drop_node = parital(update_node, value=NE)
    drop_edge = partial2(_set, NE)
    closest_neighbor = compose_all(M.argmin, np.min, neighbor_weights)
    rowproducts = compose(get_products, rowdiag)
    one_neighbor_eq = compose(itemgetter(0), neighborseq)
    def neighborseq(N, val):
        if val == 0:
            raise ValueError
        return (get(N) == val).nonzero()

    def hide_node(N):
        M.mask[N] = M.mask[:, N] = True


def both(f, g):
    def both_inner(*args, **kwargs):
        first = f(*args, **kwargs)
        return first, g(*args, **kwargs)
    return both_inner

def update(i, j, value):
    M[i,j]=value
    M[j,i]=value


class Graph(np.ndarray):
    NE = np.nan
    has_edge = partial(operator.neq, NE)

    def neighbors(self, N):
        return has_edge(self[N])















